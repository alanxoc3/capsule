#- the ax shell 0.1
i wrote up an idea for a new unix shell a month ago. since then i have refined the idea more. i'll probably improve it even more in another month.

you can see my original iteration here:

=> gemini://xoc3.io/blog/2022-03-20 the ax shell proposal

reach out to me here if you have feedback: alan@xoc3.io

## overview
the ax shell (pronounced "axe" or "acks") is an acronym for "[a]n e[x]treme [shell]". this shell strives to take the unix philosophy to the extreme. doing so means that many posix shell standards are ignored. here are a few of the design highlights of ax:

"straight forward syntax". the entire syntax should be reasonably easy to memorize. this is very unlike many unix shells currently available. after years of using bash/zsh, i still don't know all the quoting/expansion rules. not to mention that the man pages for each is massive.

"text is the only datatype". having only one datatype simplifies the shell language and encourages the use of other command line programs. arrays are represented by splitting on the null character and booleans are represented with an empty/non-empty string. mathematical operations should be done through a program suited for math.

"executables extend functionality". the list of builtins is fixed and there is no support for aliases, functions, or plugins. this implies that by improving your ax shell experience, you improve the experience of every other unix shell.

anyways, let's continue with the specification. i'm assuming previous knowledge with an existing unix shell.

## basics
ax shares many core traits with other unix shells. here is an example of commands, comments, builtins, quoting, and pipes:

```
# following should produce the same output:
echo hello world
echo   hello   world
echo 'hello world'
echo "hello world"
echo 'he'llo' "wo"r'ld'
echo -n hello; echo ' world'
echo hello | awk '{print $1 " world"}'
echo -n hello world! | tr ! \n

# builtin commands are prepended by a colon:
sudo su   # switch user to root
:cd /root # change to the /root directory
ls        # print file contents of that directory
```

a few things to note from the above example:
* text between quotes is not evaluated in any way
* echo is not a shell builtin
* builtins (like :cd) are prefixed with a colon character
* backslash doesn't need to be quoted

## nulls
one can easily join arguments together with the "?" syntax. by default, the "?" syntax joins arguments with the null character between each one, but "?" also supports joining arguments with any string:

```
# prints "hello\0world" with no trailing newline,
# \0 means the null character:
? hello world

# using tr is one way to convert the null character to something else.
# this prints "hello,world":
? hello world | tr \0 ,

# the "?" syntax has that functionality builtin though.
# this prints "hello,world":
?, hello world

# one more example, prints "hello . world":
?' . ' hello world
```

"?" defaults to splitting with the null character because of a unique property the null character has on unix systems. null is the only character that unix systems don't allow in environment variables, filenames, and command arguments. but the null character can of course be part of stdin and stdout.

ax has a few different syntaxes for converting the stdout of a command to program arguments. the null character plays a key role in each one:
* () - only get the text up to right before the first null character
* [] - split on null character and unpack each item as a separate argument
* {} - same as "[]", but remove all empty strings

here is another way to think about the capture syntaxes when you are trying to decide which one to use:
* () - expands to only 1 argument
* [] - expands to 1 or more arguments
* {} - expands to 0 or more arguments

```
# prints "hello world" to demonstrate the () syntax.
echo (? hello world) (? world hello)

# prints "hello kitty" again to demonstrate the () syntax.
echo (? hello world)' kitty'

# prints "bar foobar barbar"
echo [? '' foo bar]bar

# expands to: mv file file.backup
mv file[? '' .backup]

# ax doesn't support globbing like other shells.
# here is a way to imitate the bash equivalent of "cat *":
cat [ls | tr \n \0 | head -c -1]

# the "head -c -1" was needed because ls produces a trailing newline.
# the following is slightly easier to work with:
cat {ls | tr \n \0}

# equivalent to "ls ./*/" in bash (find and fd):
ls {find -mindepth 1 -maxdepth 1 -type d -not -path '*/.*' -print0}
ls {fd --exact-depth 1 -0It d}

# equivalent to "ls */*" in bash:
ls {find -print0 -mindepth 2 -maxdepth 2 -not -path '*/.*'}
ls {fd -0I --exact-depth 2}
```

## strings
briefly mentioned earlier, "" or '' can be used to include text in a single argument. both "" and '' in ax behave in the same way as '' in bash. that is, there is no shell expansion or even escape codes supported between the quotes.

use the "~" syntax in ax to create a string that allows any text besides a certain delimiter you specify within it. the "~" syntax is similar to heredocs in bash. example:

```
# these are equivalent:
? 'hello world' | tee file.txt;
? ~ hello world ~ | tee file.txt;
? ~// hello world //~ | tee file.txt;
? ~EOF
hello world
EOF~ | tee file.txt;

# for demonstration puposes, these are equivalent:
? ''
? ~ ~
? ~  ~

# and these are equivalent:
? ' '
? ~   ~
```

as shown in the example above, the text after the first "~" and before the whitespace character is the delimiter that is also used to end the string. the end delimiter must be the same as the start delimiter, but with a whitespace character before it and a "~" after.

use the grave "`" to escape a single character. here are some examples with escaping characters:

```
# escape builtin
# that program probably doesn't exist in your PATH, but at least it's possible.
`:cd hello

# escape a space
# prints "ab"
echo a` b # prints "helloworld"

# escape a newline
# prints "a b"
echo a `
b

# escape any special symbol:
# prints: ` ' " ? : | ; # ~ { } [ ] ( ) $
echo `` `' `" `? `: `| `; `# `~ `{ `} `[ `] `( `) `$

# the grave does nothing if added before any other character:
# prints a a . .
echo `a a `. .
```

## var
in ax, a command prefixed with "$" is actually a variable. a variable command with no arguments returns its value. a variable with arguments sets a new value and returns the new value. variables ignore stdin. here are some examples:

```
# set the "FILE" variable, write to the file, and print the output
echo hello | tee ($FILE file.txt) | true
cat ($FILE)

# ls each directory in the path
ls {%PATH | tr : \0}

# cd into the user's "Downloads" directory
:cd ($HOME)/Downloads
```

ax variables are local and do not affect the environment variables available to subprocesses. the ":env" builtin will take a snapshot of certain local variables and add them to the environment list. only up to the first null character of the local variable is set for the environment variable. ":get" returns the value of environment variables. ":del" deletes environment variables. here are some examples working closer with environment variables:

```
# some setup work, create a directory
mkdir -p ($LOCALBIN ($HOME)/.local/bin)
? "#!/bin/ax" "echo it works!" | tr 

# PATH is imported from the environment to the local variable list when the shell starts.
$PATH ($LOCALBIN):(%PATH)
% env var 1 2 3 4 5

$PATH
%PATH

:del [? % $]PATH

$PATH

# at this point, PATH is not 

```

## builtin
builtins are always prepended with a "!". unlike regular commands, builtins are able to change the shell's state. here are a few of the properties different builtins have:

* able to conditionally parse captures
* able to look at return codes and stderr through pipes
* able to set and unset environment variables

if stdin is passed to any builtin, it's treated as passing arguments to the end of the current argument list.

here's a list of all the supported builtins

```
:err    [arg]...            -- print args & stderr to stderr, concat with null character
:ret    expr...             -- print return codes of expressions to stdout, last to first
:nil    expr...             -- throw away output

:env    var...              -- copies local variables name and value to environment variables
:fork   expr...             -- run commands in parallel

:cd     [dir]...            -- change into a directory, argument list appends sub paths
:exit   [err]...            -- leave the shell, returning the last error passed

:if     [test expr]... expr -- conditional, then is printed to stdout
:loop   [test expr]... expr -- conditional loop, thens are printed to stdout
```

# easy way to get the first env var that exists
:out {APP_CONFIG} {XDG_CONFIG_DIR}/app {HOME}/.config/app /etc/app/config

## env vars
the ax shell doesn't distinguish exported variables with local variables. only exported environment variables are supported. here are a few of the environment variables that the ax shell populates for you:

```
{AX_BIN} -- the temporary directory that is prepended to the PATH variable
```

## reserved tokens
here is a list of all special tokens, along with its section and a brief description:

```
basics:
     #  -- rest of line is ignored
     ;  -- separates statements
    ' ' -- string between quotes
    " " -- string between quotes
    :cd -- change directory

pipes:
     |  -- pipes output between expressions
    ( ) -- capture stdout from expression

nulls:
     ?  -- prefix for joining
    [ ] -- unpack arguments

vars:
     $   -- prefix for variables
    :del -- delete a variable

     `  -- escape next character
     ~  -- string between ~XYZ ... XYZ~
```


## examples
as of now, that's the complete syntax for the ax shell. though the list of builtins is not complete and the syntax is still subject to change, the shell is already very powerful as these examples will show.

```
# cd into temp dir:
:cd (mktemp)

# print the text "hello world" with no trailing newline:
? 'hello world'

# or use an external program to do the same thing:
echo -n 'hello world'

# instead of aliases or functions, add to the path like this:
?(echo) "#!/bin/ax" "? {2}" | tee {AX_BIN}/print-second
print-second one two # outputs two

$1 1; $2 2; $3 3
?' ' [{2} {3}][{1} {2}] # 21 22 31 32
?' ' [(? {2 3}){1 2}]   # 21 22 31 32
?' ' [(? 2 3)(? 1 2)]   # 21 22 31 32
?' ' [21 22 31 32]      # 21 22 31 32
?' ' [{2 3}{1 2}]       # 21 22 31 32
?' ' [[2 3][1 2]]       # 21 22 31 32
[?' ' {2 3}{1 2}]       # 21 22 31 32
[[?' ' {2 3}{1 2}]]     # 21 22 31 32
?' ' [{2 3}]{1 2}       # 21 31
?' ' {2 3}{1 2}         # 21
?' ' {2}{1 2}           # 21

? [{HOME /home/{USER}/blah} ] | first

:del [($)] # delete all variables maybe



[(fd -0)]

() is a shortcut for [... | first]

() (] (}
[) [] [}
{) {] {}

(}
{)

[( )] - - expand
[{ }] - - expand

[blah blah blah]

# or you can run a string as if it were an ax script:
:set print-second "? {2}"
:exec {print-second}

(var)

1,2,3,4

# and a slightly different way to run a string:
:set print-second ? '{2}'
{print-second}

# clear all environment variables in current shell session
:del (env -0 | sed -zE 's/=.+//g')

# here is how you could make a shortcut for the above alias snippet using standard posix shell commands:
:set AX_BIN (mktemp | tr -d \n)
:set PATH   {AX_BIN}:{PATH}

# what if there are no exported variables... no.. that won't work

: blah blah blah blah

:out b ec~ ho hello | tr o <1>; echo wor ~king | tr \0 \n
alias ? <@>

:
?

? hello world | ?' ' i say

# like a function...


:set var '' # set the var to empty string
:env var -- copies var name and value to environment

env is set from env inherited and calls to :env. nothing else.
local vars is set from env, then a few extra things may be added on by the ax shell and calls to :set.

{var} -- local var

:exec <var> arg1 arg2


b l
alias a alias

    echo hello | tr o <1>; echo working
    echo done

# 137
? ~ #!/bin/ax
    :if {AX_BIN} (
        ?(echo) "#!/bin/ax" (?' ' <2:>) | tee {AX_BIN}/<1>
    ) | :nil
~ | sed -E 's/^ +//g' | tee {AX_BIN}/a | :nil

# 142
cat << EOF | sed -E 's/^ +//g' > $AX_BIN/a
    #!/bin/bash
    if [[ -n AX_BIN ]]; then
        cat << END
        #!/bin/bash
        cat <<< ${@:2} > $AX_BIN/$1
        END
    fi
EOF

# function
# alias for a line
:out ~EOF
    #!/bin/ax
    :out '#!/bin/ax' (:out <*> | tr \0 ' ') | tr \0 \n | tee {AX_BIN}/<1>
EOF | sed -E 's/^ +//g' | tee {AX_BIN}/al | :nil

a alias
a ls ls --color
func


:set 


# and using the above shortcut, you could end up creating aliases like this:
alias print-second ~EOF
    echo hello
    echo bye
    speak
    :if (sleep 1s) ()
EOF ':out {2}'

# if we had a few imaginary shell commands available, you can imagine the alias shortcut to be a bit more elegant:
:out ~EOF
    #!/bin/ax
    :out "#!/bin/ax" ":out {2}" | tr \0 \n | tee {AX_BIN}/{1}
EOF | trim | tee {AX_BIN}/alias

# here is what a conditional might look like. test is not a builtin, it's a standard unix command:
:if {VAR} (echo var is non-empty) (echo var is empty)

# in this example, the program will continuously sleep for 1 second at a time until the variable is set:
:loop (:if {VAR} '' t) (sleep 1s); echo variable is finally set

:if (test -z {VAR}) 

:join x x x x
:and x x x # prints each thing, if all things are not ''
:or  x x x # prints first thing that is not ''

# here is an if elseif statement:
:if {V1} (echo V1 is non-empty)
    {V2} (echo V2 is non-empty but V1 is empty)
         (echo both V1 and V2 are empty)



!if {axu ret sleep 1}

axfile redirect filename

cat file | fork ax 'tee /tmp/blah | nil' ^xx awk '{print "test: " $1}' xx
cat file | :fork ('tee /tmp/blah | nil') (awk '{print "test: " $1}')

```

## conclusion
some things i can think of right now that still need to be hashed out are:
* process handling
* what to do with standard error
* finalizing the list of builtins

i need to spend some time today doing something else rather than working on this blogpost now. you can see that even with a basic syntax, a powerful shell can be constructed. email me at alan@xoc3.io if you have questions or feedback about this. i'll start prototyping this shell when i consider the design to be complete, which will probably not be for many months at least.
